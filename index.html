<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tablero de Tareas Avanzado</title>
    <!-- Tailwind CSS para el diseño -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- SortableJS para Drag and Drop -->
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@latest/Sortable.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; }
        .sortable-ghost {
            opacity: 0.4;
            background: #c8ebfb;
        }
        .sortable-chosen {
            cursor: grabbing;
        }
        .task-item {
             cursor: grab;
        }
        .view {
            transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out;
        }
    </style>
</head>
<body class="bg-gray-100 flex flex-col items-center min-h-screen p-4">

    <header class="w-full max-w-5xl mb-6">
        <h1 class="text-3xl font-bold text-gray-800 text-center">Mi Tablero de Tareas</h1>
        <nav class="mt-4 flex justify-center bg-white p-2 rounded-lg shadow-sm">
            <button id="showKanbanBtn" class="px-4 py-2 text-sm font-semibold text-white bg-red-500 rounded-md shadow-sm">Tablero Kanban</button>
            <button id="showPaginatedBtn" class="px-4 py-2 text-sm font-semibold text-gray-600 ml-2">Vista Paginada</button>
        </nav>
    </header>

    <main class="w-full max-w-5xl">
        <!-- VISTA 1: TABLERO KANBAN -->
        <div id="kanban-view" class="view">
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                <!-- Columna de PENDIENTES -->
                <div class="bg-white rounded-xl shadow-lg p-6 flex flex-col">
                    <div class="flex justify-between items-center mb-4">
                        <h2 class="text-2xl font-bold text-gray-700">PENDIENTES</h2>
                        <button id="openModalBtn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold w-10 h-10 rounded-full flex items-center justify-center text-2xl transform hover:scale-110">+</button>
                    </div>
                    <div id="pending-list" class="space-y-3 flex-grow min-h-[280px] bg-gray-50 p-2 rounded-lg"></div>
                    <div id="pending-pagination" class="mt-4 flex justify-center items-center space-x-1"></div>
                </div>
                <!-- Columna de EN PROCESO -->
                <div class="bg-white rounded-xl shadow-lg p-6 flex flex-col">
                    <h2 class="text-2xl font-bold text-gray-700 mb-4">EN PROCESO</h2>
                    <div id="inprogress-list" class="space-y-3 flex-grow min-h-[280px] bg-gray-50 p-2 rounded-lg"></div>
                    <div id="inprogress-pagination" class="mt-4 flex justify-center items-center space-x-1"></div>
                </div>
            </div>
        </div>

        <!-- VISTA 2: LISTA PAGINADA -->
        <div id="paginated-view" class="view hidden">
             <div class="bg-white rounded-xl shadow-lg p-6">
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-2xl font-bold text-gray-700">Todas las Tareas</h2>
                    <div class="flex items-center space-x-2">
                        <span class="text-sm font-medium">Ver como:</span>
                        <button id="layout-list-btn" class="p-2 rounded-md bg-blue-500 text-white">Lista</button>
                        <button id="layout-grid-btn" class="p-2 rounded-md bg-gray-200 text-gray-700">Cuadrícula</button>
                    </div>
                </div>
                <div id="paginated-task-list" class="mb-4"></div>
                <div id="pagination-controls" class="flex justify-center items-center space-x-2"></div>
             </div>
        </div>
    </main>

    <!-- Modal para añadir nueva tarea -->
    <div id="taskModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 opacity-0 invisible transition-opacity duration-300">
        <div id="modalContent" class="bg-white rounded-lg shadow-xl p-6 w-full max-w-sm transform scale-95 transition-transform duration-300">
            <h2 class="text-xl font-semibold mb-4">Nueva Tarea</h2>
            <input type="text" id="taskDescription" placeholder="Ej: Implementar paginación en Kanban" class="w-full border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500">
            <div class="mt-6 flex justify-end">
                <button id="closeModalBtn" class="bg-gray-200 text-gray-700 px-4 py-2 rounded-md mr-2 hover:bg-gray-300">Cancelar</button>
                <button id="createTaskBtn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-md">Crear</button>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- STATE MANAGEMENT ---
            const kanbanItemsPerPage = 5;
            let kanbanPendingPage = 1;
            let kanbanInProgressPage = 1;
            
            let paginatedViewCurrentPage = 1;
            const paginatedViewItemsPerPage = 6;
            let currentLayout = 'list';

            // --- DOM ELEMENT SELECTION ---
            const kanbanView = document.getElementById('kanban-view');
            const paginatedView = document.getElementById('paginated-view');
            const showKanbanBtn = document.getElementById('showKanbanBtn');
            const showPaginatedBtn = document.getElementById('showPaginatedBtn');
            const pendingList = document.getElementById('pending-list');
            const inProgressList = document.getElementById('inprogress-list');
            const pendingPagination = document.getElementById('pending-pagination');
            const inProgressPagination = document.getElementById('inprogress-pagination');
            const paginatedTaskList = document.getElementById('paginated-task-list');
            const paginationControls = document.getElementById('pagination-controls');
            const layoutListBtn = document.getElementById('layout-list-btn');
            const layoutGridBtn = document.getElementById('layout-grid-btn');
            
            const openModalBtn = document.getElementById('openModalBtn');
            const closeModalBtn = document.getElementById('closeModalBtn');
            const taskModal = document.getElementById('taskModal');
            const modalContent = document.getElementById('modalContent');
            const createTaskBtn = document.getElementById('createTaskBtn');
            const taskInput = document.getElementById('taskDescription');

            // --- DATA HANDLING ---
            const getBoardData = () => JSON.parse(localStorage.getItem('kanbanBoard')) || { pending: [], inProgress: [] };
            const saveBoardData = (data) => localStorage.setItem('kanbanBoard', JSON.stringify(data));

            // --- VIEW SWITCHING LOGIC ---
            const switchView = (viewToShow) => {
                const isKanban = viewToShow === 'kanban';
                kanbanView.classList.toggle('hidden', !isKanban);
                paginatedView.classList.toggle('hidden', isKanban);
                
                showKanbanBtn.classList.toggle('bg-blue-500', isKanban);
                showKanbanBtn.classList.toggle('text-white', isKanban);
                showPaginatedBtn.classList.toggle('bg-blue-500', !isKanban);
                showPaginatedBtn.classList.toggle('text-white', !isKanban);

                if (isKanban) {
                    renderKanbanBoard();
                } else {
                    renderPaginatedView();
                }
            };

            // --- KANBAN VIEW LOGIC ---
            const renderKanbanBoard = () => {
                const data = getBoardData();
                
                // Paginate and render PENDING column
                const pendingStartIndex = (kanbanPendingPage - 1) * kanbanItemsPerPage;
                const pendingEndIndex = pendingStartIndex + kanbanItemsPerPage;
                const paginatedPending = data.pending.slice(pendingStartIndex, pendingEndIndex);
                
                pendingList.innerHTML = '';
                paginatedPending.forEach(text => pendingList.appendChild(createTaskElement(text)));
                renderKanbanPagination('pending', data.pending.length, kanbanPendingPage, pendingPagination);

                // Paginate and render IN-PROGRESS column
                const inProgressStartIndex = (kanbanInProgressPage - 1) * kanbanItemsPerPage;
                const inProgressEndIndex = inProgressStartIndex + kanbanItemsPerPage;
                const paginatedInProgress = data.inProgress.slice(inProgressStartIndex, inProgressEndIndex);

                inProgressList.innerHTML = '';
                paginatedInProgress.forEach(text => inProgressList.appendChild(createTaskElement(text)));
                renderKanbanPagination('inProgress', data.inProgress.length, kanbanInProgressPage, inProgressPagination);
            };
            
            const createTaskElement = (text) => {
                const item = document.createElement('div');
                item.className = 'task-item bg-white p-3 rounded-md shadow-sm border border-gray-200';
                item.textContent = text;
                return item;
            };

            const renderKanbanPagination = (columnType, totalItems, currentPage, container) => {
                container.innerHTML = '';
                const totalPages = Math.ceil(totalItems / kanbanItemsPerPage);
                if (totalPages <= 1) return;

                for (let i = 1; i <= totalPages; i++) {
                    const pageBtn = document.createElement('button');
                    pageBtn.textContent = i;
                    pageBtn.className = `w-8 h-8 rounded-md text-sm font-semibold ${currentPage === i ? 'bg-blue-500 text-white' : 'bg-gray-200 text-gray-700'}`;
                    pageBtn.onclick = () => {
                        if (columnType === 'pending') {
                            kanbanPendingPage = i;
                        } else {
                            kanbanInProgressPage = i;
                        }
                        renderKanbanBoard();
                    };
                    container.appendChild(pageBtn);
                }
            };

            // --- DRAG AND DROP LOGIC ---
            const initDragAndDrop = () => {
                const options = {
                    group: 'tasks',
                    animation: 150,
                    ghostClass: 'sortable-ghost',
                    chosenClass: 'sortable-chosen',
                    onEnd: updateDataFromDOM
                };
                Sortable.create(pendingList, options);
                Sortable.create(inProgressList, options);
            };

            const updateDataFromDOM = () => {
                // This function now needs to get ALL tasks, not just the visible ones.
                // It's simpler to re-read from localStorage, update, save, and re-render.
                const data = getBoardData();

                const pendingTasksOnScreen = Array.from(pendingList.children).map(item => item.textContent);
                const inProgressTasksOnScreen = Array.from(inProgressList.children).map(item => item.textContent);
                
                // Reconstruct the full lists
                const newPending = [...data.pending];
                const newInProgress = [...data.inProgress];

                // This logic is complex. A simpler approach is to rebuild the arrays from the DOM,
                // but that only works if all items are in the DOM. With pagination, they are not.
                // The most robust way is to find what moved where, but SortableJS doesn't tell us directly.
                
                // **Simplified approach for this example**: we will rebuild the data from the DOM,
                // which means drag-and-drop will only work for items currently visible on the page.
                // A full solution would require a more complex state management.
                
                // Let's get the full lists from the DOM before SortableJS re-arranges them visually
                // This is a limitation. For a truly robust solution, one would use a library like React or Vue.
                
                // The onEnd event gives us the new state of the visible items.
                // We need to update the main data array.
                // For simplicity, we'll just re-read the DOM and save. This means drag-drop across pages is not possible.
                const newPendingData = Array.from(document.getElementById('pending-list').children).map(t => t.textContent);
                const newInProgressData = Array.from(document.getElementById('inprogress-list').children).map(t => t.textContent);

                // This is a naive update and will lose tasks on other pages.
                // Let's fix this. We need to get the moved item and update the original full arrays.
                // SortableJS `onEnd` event provides `evt.oldIndex`, `evt.newIndex`, `evt.from`, `evt.to`.
                
                // Let's rewrite the onEnd handler.
                Sortable.create(pendingList, {
                    group: 'tasks', animation: 150, ghostClass: 'sortable-ghost',
                    onEnd: (evt) => handleDragEnd(evt, 'pending')
                });
                Sortable.create(inProgressList, {
                    group: 'tasks', animation: 150, ghostClass: 'sortable-ghost',
                    onEnd: (evt) => handleDragEnd(evt, 'inProgress')
                });
            };
            
            const handleDragEnd = (evt) => {
                const data = getBoardData();
                const fromListId = evt.from.id;
                const toListId = evt.to.id;
                const oldIndex = evt.oldIndex;
                const newIndex = evt.newIndex;

                const fromPageIndex = fromListId === 'pending-list' ? kanbanPendingPage : kanbanInProgressPage;
                const toPageIndex = toListId === 'pending-list' ? kanbanPendingPage : kanbanInProgressPage;

                const absoluteOldIndex = ((fromPageIndex - 1) * kanbanItemsPerPage) + oldIndex;
                const absoluteNewIndex = ((toPageIndex - 1) * kanbanItemsPerPage) + newIndex;

                let sourceArray = fromListId === 'pending-list' ? data.pending : data.inProgress;
                let targetArray = toListId === 'pending-list' ? data.pending : data.inProgress;

                // Remove item from source array
                const [movedItem] = sourceArray.splice(absoluteOldIndex, 1);
                
                // Add item to target array
                targetArray.splice(absoluteNewIndex, 0, movedItem);

                // Adjust current page if a list becomes empty
                if (Math.ceil(data.pending.length / kanbanItemsPerPage) < kanbanPendingPage) {
                    kanbanPendingPage = Math.max(1, kanbanPendingPage - 1);
                }
                 if (Math.ceil(data.inProgress.length / kanbanItemsPerPage) < kanbanInProgressPage) {
                    kanbanInProgressPage = Math.max(1, kanbanInProgressPage - 1);
                }

                saveBoardData(data);
                renderKanbanBoard(); // Re-render the entire board from the updated data
            };


            // --- PAGINATED VIEW LOGIC ---
            const renderPaginatedView = () => {
                const data = getBoardData();
                const allTasks = [...data.pending, ...data.inProgress];
                paginatedTaskList.innerHTML = '';

                paginatedTaskList.className = currentLayout === 'grid' 
                    ? 'grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-4' 
                    : 'space-y-3';
                
                const startIndex = (paginatedViewCurrentPage - 1) * paginatedViewItemsPerPage;
                const endIndex = startIndex + paginatedViewItemsPerPage;
                const paginatedTasks = allTasks.slice(startIndex, endIndex);

                if (paginatedTasks.length === 0 && paginatedViewCurrentPage > 1) {
                    paginatedViewCurrentPage--;
                    renderPaginatedView();
                    return;
                }

                paginatedTasks.forEach(text => {
                    const item = document.createElement('div');
                    item.className = 'bg-gray-50 p-4 rounded-lg shadow-sm border';
                    item.textContent = text;
                    paginatedTaskList.appendChild(item);
                });
                
                renderPaginatedViewControls(allTasks.length);
            };

            const renderPaginatedViewControls = (totalItems) => {
                const totalPages = Math.ceil(totalItems / paginatedViewItemsPerPage);
                paginationControls.innerHTML = '';
                if (totalPages <= 1) return;

                const prevBtn = document.createElement('button');
                prevBtn.textContent = 'Anterior';
                prevBtn.className = 'px-4 py-2 bg-gray-200 rounded-md disabled:opacity-50';
                prevBtn.disabled = paginatedViewCurrentPage === 1;
                prevBtn.onclick = () => { paginatedViewCurrentPage--; renderPaginatedView(); };
                paginationControls.appendChild(prevBtn);

                const pageInfo = document.createElement('span');
                pageInfo.textContent = `Página ${paginatedViewCurrentPage} de ${totalPages}`;
                pageInfo.className = 'text-sm text-gray-700';
                paginationControls.appendChild(pageInfo);

                const nextBtn = document.createElement('button');
                nextBtn.textContent = 'Siguiente';
                nextBtn.className = 'px-4 py-2 bg-gray-200 rounded-md disabled:opacity-50';
                nextBtn.disabled = paginatedViewCurrentPage === totalPages;
                nextBtn.onclick = () => { paginatedViewCurrentPage++; renderPaginatedView(); };
                paginationControls.appendChild(nextBtn);
            };
            
            const changeLayout = (layout) => {
                currentLayout = layout;
                layoutListBtn.classList.toggle('bg-blue-500', layout === 'list');
                layoutListBtn.classList.toggle('text-white', layout === 'list');
                layoutGridBtn.classList.toggle('bg-blue-500', layout === 'grid');
                layoutGridBtn.classList.toggle('text-white', layout === 'grid');
                renderPaginatedView();
            };

            // --- MODAL AND TASK CREATION LOGIC ---
            const openModal = () => {
                taskModal.classList.remove('invisible', 'opacity-0');
                modalContent.classList.remove('scale-95');
                taskInput.focus();
            };
            const closeModal = () => {
                taskModal.classList.add('invisible', 'opacity-0');
                modalContent.classList.add('scale-95');
                taskInput.value = '';
            };
            const addTask = () => {
                const taskText = taskInput.value.trim();
                if (taskText) {
                    const data = getBoardData();
                    data.pending.push(taskText);
                    // Go to the last page of the pending column to see the new task
                    kanbanPendingPage = Math.ceil(data.pending.length / kanbanItemsPerPage) || 1;
                    saveBoardData(data);
                    renderKanbanBoard();
                    closeModal();
                }
            };
            
            // --- EVENT LISTENERS ---
            showKanbanBtn.addEventListener('click', () => switchView('kanban'));
            showPaginatedBtn.addEventListener('click', () => switchView('paginated'));
            layoutListBtn.addEventListener('click', () => changeLayout('list'));
            layoutGridBtn.addEventListener('click', () => changeLayout('grid'));
            openModalBtn.addEventListener('click', openModal);
            closeModalBtn.addEventListener('click', closeModal);
            createTaskBtn.addEventListener('click', addTask);
            taskModal.addEventListener('click', (e) => e.target === taskModal && closeModal());

            // --- INITIALIZATION ---
            // The drag and drop init needs to be more robust for pagination
            // Let's rewrite the init logic for Sortable
            const createSortable = (element) => {
                Sortable.create(element, {
                    group: 'tasks',
                    animation: 150,
                    ghostClass: 'sortable-ghost',
                    onEnd: handleDragEnd
                });
            };
            createSortable(pendingList);
            createSortable(inProgressList);
            renderKanbanBoard();
        });
    </script>
</body>
</html>

